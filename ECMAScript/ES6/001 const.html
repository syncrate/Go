<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>

</body>
</html>
<script>
    /**
     * @description: const声明一个只读的常量。一旦声明，常量的值就不能改变。
     */
    // const PI = 3.1415;
    // PI // 3.1415
    // PI = 3;// TypeError: Assignment to constant variable.
    /**
     * @kind:
     * 1.const声明的变量不得改变值，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值。
     * 2.const的作用域与let命令相同：只在声明所在的块级作用域内有效。
     * 3.const命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。
     * 4.const声明的常量，也与let一样不可重复声明。
     * 5.<本质 const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。对于简单类型的数据（数值、字符串、布尔值），
     * 值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），
     * 变量指向的内存地址，保存的只是一个指向实际数据的指针，const只能保证这个指针是固定的（即总是指向另一个固定的地址），
     * 至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。>
     **/

    // const foo = {};
    // // 为 foo 添加一个属性，可以成功
    // foo.prop = 123;
    // foo.prop // 123
    // // 将 foo 指向另一个对象，就会报错
    // foo = {}; // TypeError: "foo" is read-only

    /**
     * 上面代码中，常量foo储存的是一个地址，这个地址指向一个对象。
     * 不可变的只是这个地址，即不能把foo指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。
     */

    /**
     * @description: ES6 声明变量的六种方法
     * ES5 只有两种声明变量的方法：var命令和function命令。
     * ES6 除了添加let和const命令，后面章节还会提到，另外两种声明变量的方法：
     * import命令和class命令。所以，ES6 一共有 6 种声明变量的方法。
     */

    /**
     * @description: 4. 顶层对象的属性
     * 顶层对象，在浏览器环境指的是window对象，在 Node 指的是global对象。
     * ES5之中，顶层对象的属性与全局变量是等价的。
     * <ES6 为了改变这一点，一方面规定，为了保持兼容性，
     * var命令和function命令声明的全局变量，依旧是顶层对象的属性；
     * 另一方面规定，let命令、const命令、class命令声明的全局变量，
     * 不属于顶层对象的属性。也就是说，从 ES6 开始，全局变量将逐步与顶层对象的属性脱钩。>
     */

    /**
     * ES2020 在语言标准的层面，引入globalThis作为顶层对象。也就是说，任何环境下，globalThis都是存在的，都可以从它拿到顶层对象，指向全局环境下的this。
     * 垫片库global-this模拟了这个提案，可以在所有环境拿到globalThis。
     * ES6 新增了let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。
     */

</script>