<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>

</body>
</html>
<script>
    /**
     * @description: 1. String.fromCodePoint()
     * <ES5 提供 String.fromCharCode() 方法，用于从 Unicode 码点返回对应字符，但是这个方法不能识别码点大于 0xFFFF 的字符>
     * <ES6 提供了 String.fromCodePoint()方法，可以识别大于 0xFFFF 的字符，弥补了 String.fromCharCode() 方法的不足。
     * 在作用上，正好与下面的 codePointAt() 方法相反。>
     */
    console.log(String.fromCodePoint(0x20BB7))
    console.log(String.fromCodePoint(0x78, 0x1f680, 0x79)=== 'x\uD83D\uDE80y');
    //上面代码中，如果 String.fromCodePoint 方法有多个参数，则它们会被合并成一个字符串返回。
    //注意， fromCodePoint 方法定义在 String 对象上，而 codePointAt 方法定义在字符串的实例对象上。

    /**
     * @description: 2. String.raw() 原生字符串
     * <ES6 还为原生的 String 对象，提供了一个 raw()方法。该方法返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，往往用于模板字符串的处理方法。>
     * < String.raw() 本质上是一个正常的函数，只是专用于模板字符串的标签函数。
     * 如果写成正常函数的形式，它的第一个参数，应该是一个具有 raw 属性的对象，且 raw 属性的值应该是一个数组，对应模板字符串解析后的值。>
     */
    console.log(String.raw`Hi\n${2+3}!`);
    console.log(String.raw`Hi\u000A!`);
    // `foo${1 + 2}bar`
    // 等同于
    String.raw({ raw: ['foo', 'bar'] }, 1 + 2) // "foo3bar"

    /**
     * @description: 3. 实例方法：codePointAt()
     * <JavaScript 内部，字符以UTF-16 的格式储存，每个字符固定为 2 个字节。
     * 对于那些需要 4 个字节储存的字符（Unicode 码点大于 0xFFFF 的字符），JavaScript 会认为它们是两个字符。>
     * <ES6 提供了 codePointAt() 方法，能够正确处理 4 个字节储存的字符，返回一个字符的码点。>
     */
    let string_code='吉祥'
    string_code.codePointAt()
</script>